// Generated by Melange

import * as Stdlib__List from "melange/list.js";
import * as Webapi__Canvas__Canvas2d from "melange-webapi/Webapi/Canvas/Webapi__Canvas__Canvas2d.js";

function move_ball(canvas_state, color, state) {
  const ball = color === /* Black */0 ? state.black_ball : state.white_ball;
  const ball$1 = (ball.x + ball.dx | 0) > (canvas_state.width - ball.radius | 0) || (ball.x + ball.dx | 0) < ball.radius ? ({
        x: ball.x,
        y: ball.y,
        dx: -ball.dx | 0,
        dy: ball.dy,
        radius: ball.radius,
        color: ball.color
      }) : ball;
  const ball$2 = (ball$1.y + ball$1.dy | 0) > (canvas_state.height - ball$1.radius | 0) || (ball$1.y + ball$1.dy | 0) < ball$1.radius ? ({
        x: ball$1.x,
        y: ball$1.y,
        dx: ball$1.dx,
        dy: -ball$1.dy | 0,
        radius: ball$1.radius,
        color: ball$1.color
      }) : ball$1;
  const ball_x = ball$2.x + ball$2.dx | 0;
  const ball_y = ball$2.y + ball$2.dy | 0;
  const ball_dx = ball$2.dx;
  const ball_dy = ball$2.dy;
  const ball_radius = ball$2.radius;
  const ball_color = ball$2.color;
  const ball$3 = {
    x: ball_x,
    y: ball_y,
    dx: ball_dx,
    dy: ball_dy,
    radius: ball_radius,
    color: ball_color
  };
  if (color) {
    return {
            black_ball: state.black_ball,
            white_ball: ball$3,
            cells: state.cells
          };
  } else {
    return {
            black_ball: ball$3,
            white_ball: state.white_ball,
            cells: state.cells
          };
  }
}

function cell_and_ball_collides(cell, ball) {
  if (ball.x >= (Math.imul(cell.col, 40) - ball.radius | 0) && ball.x <= ((Math.imul(cell.col, 40) + 40 | 0) + ball.radius | 0) && ball.y >= (Math.imul(cell.row, 40) - ball.radius | 0) && ball.y <= ((Math.imul(cell.row, 40) + 40 | 0) + ball.radius | 0)) {
    return ball.color === cell.color;
  } else {
    return false;
  }
}

function horizontal_collision(cell, ball) {
  if ((ball.x + ball.radius | 0) <= Math.imul(cell.col, 40)) {
    return true;
  } else {
    return (ball.x - ball.radius | 0) >= (Math.imul(cell.col, 40) + 40 | 0);
  }
}

function cell_and_ball_after_collision(cell, ball) {
  if (!cell_and_ball_collides(cell, ball)) {
    return [
            cell,
            ball
          ];
  }
  const ball$1 = horizontal_collision(cell, ball) ? ({
        x: ball.x,
        y: ball.y,
        dx: -ball.dx | 0,
        dy: ball.dy,
        radius: ball.radius,
        color: ball.color
      }) : ({
        x: ball.x,
        y: ball.y,
        dx: ball.dx,
        dy: -ball.dy | 0,
        radius: ball.radius,
        color: ball.color
      });
  return [
          {
            row: cell.row,
            col: cell.col,
            color: cell.color ? /* Black */0 : /* White */1
          },
          ball$1
        ];
}

function ball_collision_detection(color, state) {
  const cells = Stdlib__List.filter((function (cell) {
          return cell.color === color;
        }), state.cells);
  const ball = color === /* Black */0 ? state.black_ball : state.white_ball;
  const colliding_cell = Stdlib__List.find_opt((function (cell) {
          return cell_and_ball_collides(cell, ball);
        }), cells);
  if (colliding_cell === undefined) {
    return state;
  }
  const match = cell_and_ball_after_collision(colliding_cell, ball);
  const ball$1 = match[1];
  const new_cell = match[0];
  const cells$1 = Stdlib__List.map((function (cell) {
          if (cell.row === new_cell.row && cell.col === new_cell.col) {
            return new_cell;
          } else {
            return cell;
          }
        }), state.cells);
  if (color) {
    return {
            black_ball: state.black_ball,
            white_ball: ball$1,
            cells: cells$1
          };
  } else {
    return {
            black_ball: ball$1,
            white_ball: state.white_ball,
            cells: cells$1
          };
  }
}

function next_state(canvas_state, state) {
  return move_ball(canvas_state, /* White */1, move_ball(canvas_state, /* Black */0, ball_collision_detection(/* White */1, ball_collision_detection(/* Black */0, state))));
}

function draw_cells(canvas_state, state) {
  Stdlib__List.iter((function (cell) {
          canvas_state.ctx.beginPath();
          canvas_state.ctx.rect(Math.imul(cell.col, 40), Math.imul(cell.row, 40), 40, 40);
          const match = cell.color;
          Webapi__Canvas__Canvas2d.setFillStyle(canvas_state.ctx, /* String */0, match ? "grey" : "black");
          canvas_state.ctx.fill();
          canvas_state.ctx.closePath();
        }), state.cells);
}

function draw_ball(canvas_state, ball, color) {
  const ctx = canvas_state.ctx;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2, false);
  Webapi__Canvas__Canvas2d.setFillStyle(ctx, /* String */0, color ? "grey" : "black");
  ctx.fill();
  ctx.closePath();
}

function draw(canvas_state, state) {
  canvas_state.ctx.clearRect(0, 0, canvas_state.width, canvas_state.height);
  draw_cells(canvas_state, state);
  draw_ball(canvas_state, state.white_ball, /* White */1);
  draw_ball(canvas_state, state.black_ball, /* Black */0);
}

function loop(canvas_state, state) {
  draw(canvas_state, state);
  requestAnimationFrame(function (param) {
        loop(canvas_state, next_state(canvas_state, state));
      });
}

const canvas_element = document.getElementById("canvas");

if (!(canvas_element == null)) {
  canvas_element.getContext("2d");
  const canvas_state_ctx = canvas_element.getContext("2d");
  const canvas_state_height = canvas_element.height;
  const canvas_state_width = canvas_element.width;
  const canvas_state = {
    element: canvas_element,
    ctx: canvas_state_ctx,
    height: canvas_state_height,
    width: canvas_state_width
  };
  loop(canvas_state, {
        black_ball: {
          x: 100,
          y: canvas_state_height - 20 | 0,
          dx: 1,
          dy: -1,
          radius: 10,
          color: /* Black */0
        },
        white_ball: {
          x: (canvas_state_width - 40 | 0) - 20 | 0,
          y: 10,
          dx: -1,
          dy: 1,
          radius: 10,
          color: /* White */1
        },
        cells: Stdlib__List.flatten(Stdlib__List.init(10, (function (row) {
                    return Stdlib__List.init(10, (function (col) {
                                  return {
                                          row: row,
                                          col: col,
                                          color: row > col ? /* White */1 : /* Black */0
                                        };
                                }));
                  })))
      });
}

export {
  
}
/* canvas_element Not a pure module */
